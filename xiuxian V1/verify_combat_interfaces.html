<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æˆ˜æ–—å¼•æ“æ¥å£ä¸å‹åˆ¶è§„åˆ™éªŒè¯</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #f5f5f5; color: #333; }
        .container { max-width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .box { border: 1px solid #eee; padding: 15px; margin-bottom: 20px; border-radius: 4px; }
        .box h3 { margin-top: 0; color: #444; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        .pass { color: #27ae60; font-weight: bold; }
        .fail { color: #c0392b; font-weight: bold; }
        .log-line { font-family: monospace; font-size: 0.9em; padding: 2px 0; border-bottom: 1px dashed #eee; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª æˆ˜æ–—å¼•æ“æ¥å£ä¸å‹åˆ¶è§„åˆ™éªŒè¯(V1.7)</h1>

        <div class="box">
            <h3>1. åŸºç¡€æ¥å£æ£€æŸ¥</h3>
            <div id="result-1">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>2. RNG æ³¨å…¥æµ‹è¯• (å¯é¢„æµ‹)</h3>
            <p>æ³¨å…¥å›ºå®šéšæœºæ•°(æ€»æ˜¯è¿”å› 0.99)ï¼Œä¼¤å®³åº”ç¨³å®šä¸ºæœ€å¤§å€¼ã€‚</p>
            <div id="result-2">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>3. å¢ƒç•Œå‹åˆ¶è§„åˆ™æ’æ‹”æµ‹è¯•</h3>
            <p>ä¸ä¿®æ”¹å¼•æ“ä»£ç ï¼Œä»…é€šè¿‡ options æ³¨å…¥è§„åˆ™ã€‚</p>
            <div id="result-3">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>4. å¤šæ€ªæ¥å£æµ‹è¯•</h3>
            <p>éªŒè¯ context.monstersã€activeTargetIdã€delta.monsters ä¸èƒœåˆ©æ¡ä»¶ã€‚</p>
            <div id="result-4">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>5. çŠ¶æ€ä¸è§„åˆ™æ’ä»¶æµ‹è¯•</h3>
            <p>éªŒè¯ rules.skill/status æ³¨å…¥èƒ½å½±å“è¾“å‡ºä¸”ä¿æŒçº¯å‡½æ•°ã€‚</p>
            <div id="result-5">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>6. Phase é€ä¼ æµ‹è¯•</h3>
            <p>éªŒè¯ context.phase ç”±é€»è¾‘å±‚å†³å®šï¼Œå¼•æ“åªè¯»å¹¶é€ä¼ ç»™ rule è¾“å…¥ (battlePhase)ã€‚</p>
            <div id="result-6">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>7. æ¸¡åŠ«äº‹ä»¶ä¸å¿ƒé­”æ¥å£æµ‹è¯•</h3>
            <p>éªŒè¯ EventSystem/HeartDemonSystem å­˜åœ¨æ€§ä¸æœ€å°å¯è¿è¡Œæ€§ã€‚</p>
            <div id="result-7">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>8. å¿ƒé­”é¢„ç®—ä¸ä¸Šé™çº¦æŸæµ‹è¯•</h3>
            <p>éªŒè¯ effectLimitPerRound / powerBudgetPerRound / maxStatusDuration ç”Ÿæ•ˆã€‚</p>
            <div id="result-8">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>9. äº‹ä»¶é€‰é¡¹ç™½åå•æ ¡éªŒæµ‹è¯•</h3>
            <p>éªŒè¯ EventSystem æ‹’ç» if/weight/condition/when ç­‰å­—æ®µã€‚</p>
            <div id="result-9">ç­‰å¾…æµ‹è¯•...</div>
        </div>
        <div class="box">
            <h3>10. V2 æ¶æ„ç‰¹æ€§éªŒè¯ (Safety, Declarative, Debug)</h3>
            <p>éªŒè¯éæ³•çŠ¶æ€æ‹¦æˆªã€å£°æ˜å¼è§„åˆ™å…ƒæ•°æ®ã€å¿ƒé­” Debug æ—¥å¿—ã€‚</p>
            <div id="result-10">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>11. å­˜æ¡£/å›æ”¾ä¸€è‡´æ€§æ ¡éªŒ (V2)</h3>
            <p>åŸºäºç§å­ RNG çš„çŠ¶æ€å›æ”¾ä¸€è‡´æ€§æµ‹è¯•ã€‚</p>
            <div id="result-11">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>12. Rules å¯è§†åŒ– / å‚æ•°åŒ– (V2)</h3>
            <p>ä» ruleMeta è‡ªåŠ¨ç”Ÿæˆè¾“å…¥/è¾“å‡ºè¯´æ˜ï¼Œå¹¶æ”¯æŒ JSON è°ƒå‚ï¼ˆå¼€å‘ç”¨ï¼‰ã€‚</p>
            <div id="rules-panel">ç­‰å¾…åˆå§‹åŒ–...</div>
        </div>

        <div class="box">
            <h3>13. å¿ƒé­”æ€§æ ¼æ¨¡æ¿å¤šæ ·æ€§éªŒè¯ (V2)</h3>
            <p>åœ¨ç›¸åŒé¢„ç®—ä¸‹ï¼Œä¸åŒæ€§æ ¼åº”è¡¨ç°å‡ºä¸åŒè¡Œä¸ºå€¾å‘ï¼ˆéæ›´å¼ºï¼‰ã€‚</p>
            <div id="result-13">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <div class="box">
            <h3>14. å†…å®¹é©±åŠ¨éªŒè¯ï¼š3â€“5 å¤©å™äº‹äº‹ä»¶é“¾å›æ”¾ (V2)</h3>
            <p>ç”¨ State + Rules + Event æ¨è¿›å™äº‹é“¾ï¼Œå¹¶éªŒè¯åŒ seed ä¸€è‡´æ€§ã€‚</p>
            <div id="result-14">ç­‰å¾…æµ‹è¯•...</div>
            <div id="timeline-14" style="margin-top:10px;">ç­‰å¾…æ—¶é—´çº¿...</div>
        </div>

        <div class="box">
            <h3>15. å™äº‹é“¾ï¼šå¿ƒå¢ƒå´©è£‚é“¾ï¼ˆmindfractureï¼‰å›æ”¾éªŒè¯</h3>
            <p>éªŒè¯ 5 å¤©æ¨è¿›ã€éšè—çŠ¶æ€æ——æ ‡ã€rate å½±å“ï¼ˆä¸æ˜¾ç¤ºæ•°å€¼ï¼‰ä¸ Day5 å¿ƒé­”ç»“ç®—ã€‚</p>
            <div id="result-15">ç­‰å¾…æµ‹è¯•...</div>
            <div id="timeline-15" style="margin-top:10px;">ç­‰å¾…æ—¶é—´çº¿...</div>
        </div>

        <div class="box">
            <h3>16. World Tendency å›æ”¾ä¸€è‡´æ€§éªŒè¯ (v1.2)</h3>
            <p>å›ºå®š seed ä¸äº‹ä»¶è·¯å¾„ï¼Œå¯¹æ¯” tendencies hashã€äº‹ä»¶åºåˆ—ä¸ deltaKeyï¼›Echo ä¸çº³å…¥æ–­è¨€ã€‚</p>
            <div id="result-16">ç­‰å¾…æµ‹è¯•...</div>
            <div id="timeline-16" style="margin-top:10px;">ç­‰å¾…æ—¶é—´çº¿...</div>
        </div>

        <div class="box">
            <h3>17. Replay æ ¼å¼ä¸å…¨é“¾è·¯é‡æ”¾ï¼ˆäº‹ä»¶â†’å¿ƒé­”â†’ç»“ç®—ï¼‰</h3>
            <p>ä»ä¸€æ¬¡æ¨¡æ‹Ÿç”Ÿæˆ replay(actions)ï¼Œå†ç”¨ replay é©±åŠ¨ tick+event å¤ç°ï¼Œå¹¶å¯¹æ¯” hash/åºåˆ—ã€‚</p>
            <div id="result-17">ç­‰å¾…æµ‹è¯•...</div>
            <div id="timeline-17" style="margin-top:10px;">ç­‰å¾…æ—¶é—´çº¿...</div>
        </div>
    </div>

    <!-- åŠ è½½æ ¸å¿ƒ -->
    <script src="js/data.js"></script>
    <script src="js/data_skills_common.js"></script>
    <script src="js/data_skills_ghost.js"></script>
    <script src="js/data_skills_yinyang.js"></script>
    <script src="js/data_skills_qiankun.js"></script>
    <script src="js/data_skills_tianyi.js"></script>
    <script src="js/state.js"></script>
    <script src="js/combat_engine.js"></script>
    <script src="js/logic.js"></script>

    <script>
        function assert(condition, msg) {
            return condition ? `<span class="pass">âœ” PASS: ${msg}</span>` : `<span class="fail">âœ˜ FAIL: ${msg}</span>`;
        }

        const mockContext = {
            player: { hp: 100, mp: 100, atk: 10, realm: "å¯»é“", subRealm: "åˆæœŸ", activeDao: "éšæœº", maxHp: 100 },
            monster: { hp: 500, atk: 5, name: "æœ¨æ¡©", dangerLevel: 1 },
            env: { mapId: "æµ‹è¯•åœº", difficulty: 1 }
        };

        // --- æµ‹è¯• 1: æ¥å£å­˜åœ¨æ€§ ---
        const r1 = document.getElementById('result-1');
        const engineExists = typeof CombatEngine !== 'undefined';
        const runIsFunc = engineExists && typeof CombatEngine.run === 'function';
        r1.innerHTML = `
            ${assert(engineExists, "CombatEngine å¯¹è±¡å­˜åœ¨")}<br>
            ${assert(runIsFunc, "CombatEngine.run å‡½æ•°å­˜åœ¨")}<br>
            ${assert(CombatEngine.run.length >= 1, "CombatEngine.run æ¥å—å‚æ•°")}
        `;

        // --- æµ‹è¯• 2: RNG æ³¨å…¥ ---
        const r2 = document.getElementById('result-2');
        // å›ºå®š RNGï¼šæ€»æ˜¯è¿”å› 0.99 (æœ€å¤§éšæœºå€¼)
        const maxRng = () => 0.99; 
        // æœŸæœ›ä¼¤å®³è®¡ç®—: (10 + 0) * 1.0(åŒé˜¶æ— å‹åˆ¶) * (0.9 + 0.99*0.2 = 1.098) = 10.98 -> 10
        // å¼ºåˆ¶ä½¿ç”¨æ™®æ”»ï¼ˆé€šè¿‡è®¾ç½®æé«˜è“è€—çš„å‡æŠ€èƒ½è¿«ä½¿å›è½åˆ°æ™®æ”»é€»è¾‘ï¼‰
        const res2 = CombatEngine.run(JSON.parse(JSON.stringify(mockContext)), maxRng, { skill: { mpCost: 99999 } });
        // éªŒè¯æ—¥å¿—é‡Œæ˜¯å¦æœ‰ä¼¤å®³æ•°å€¼
        const dmgLog = res2.logs.find(l => l.text.includes('ä¼¤å®³'));
        r2.innerHTML = `
            ${assert(res2, "è¿è¡ŒæˆåŠŸè¿”å›ç»“æœ")}<br>
            æ—¥å¿—è¾“å‡º: <span class="log-line">${dmgLog ? dmgLog.text : "æ— ä¼¤å®³æ—¥å¿—"}</span><br>
            ${assert(dmgLog && dmgLog.text.includes('10'), "ä¼¤å®³å€¼ç¬¦åˆé¢„æœŸ (æœ€å¤§éšæœºå€¼)")}
        `;

        // --- æµ‹è¯• 3: å¢ƒç•Œå‹åˆ¶æ’æ‹” ---
        const r3 = document.getElementById('result-3');
        
        const parsePlayerDamage = (res) => {
            const log = res && Array.isArray(res.logs)
                ? res.logs.find(l => l && typeof l.text === 'string' && (l.tag === 'dmg' || l.tag === 'skill') && l.text.includes('é€ æˆ') && l.text.includes('ä¼¤å®³'))
                : null;
            const m = log && log.text.match(/é€ æˆ\s*(\d+)\s*ä¼¤å®³/);
            return m ? parseInt(m[1], 10) : 0;
        };
        const parseTakenDamage = (res) => {
            const log = res && Array.isArray(res.logs)
                ? res.logs.find(l => l && typeof l.text === 'string' && l.tag === 'dmg-taken' && l.text.includes('å—åˆ°') && l.text.includes('ä¼¤å®³'))
                : null;
            const m = log && log.text.match(/å—åˆ°\s*(\d+)\s*ä¼¤å®³/);
            return m ? parseInt(m[1], 10) : 0;
        };

        // 3.1 é»˜è®¤è¿è¡Œ (æ— å‹åˆ¶) â€”â€” å¼ºåˆ¶æ™®æ”»ï¼Œé¿å…æŠ½åˆ°éä¼¤å®³æŠ€èƒ½å½±å“æµ‹è¯•
        const resNormal = CombatEngine.run(JSON.parse(JSON.stringify(mockContext)), maxRng, { skill: { mpCost: 99999 } });
        const dmgNormal = parsePlayerDamage(resNormal);
        const takenNormal = parseTakenDamage(resNormal);

        // 3.2 æ³¨å…¥â€œåå€ç•Œç‹æ‹³â€è§„åˆ™
        // ä¿®æ­£ï¼šrealmRule å¿…é¡»æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ¥æ”¶ input è¿”å›å‹åˆ¶å¯¹è±¡
        const tenTimesRule = (input) => ({
            damageMult: 10,
            takenMult: 0.1, // é¡ºä¾¿æµ‹è¯•å—ä¼¤å€ç‡
            logs: [{ type: 'battle', text: '>>> [ç•Œç‹æ‹³] æˆ˜æ–—åŠ›åå€çˆ†å‘ï¼' }]
        });
        
        try {
            const resBoosted = CombatEngine.run(JSON.parse(JSON.stringify(mockContext)), maxRng, {
                skill: { mpCost: 99999 },
                enableRealmSuppression: true,
                rules: { realm: tenTimesRule }
            });
            
            const dmgBoosted = parsePlayerDamage(resBoosted);
            const takenBoosted = parseTakenDamage(resBoosted);

            r3.innerHTML = `
                æ™®é€šä¼¤å®³: ${dmgNormal}<br>
                å‹åˆ¶è§„åˆ™åä¼¤å®³: ${dmgBoosted}<br>
                æ™®é€šå—ä¼¤: ${takenNormal}<br>
                å—ä¼¤å€ç‡å: ${takenBoosted}<br>
                é¢å¤–æ—¥å¿—: <span class="log-line">${resBoosted.logs.find(l => l.text.includes('ç•Œç‹æ‹³'))?.text || "æœªæ‰¾åˆ°"}</span><br>
                ${assert(dmgBoosted >= dmgNormal * 9, "ä¼¤å®³æ˜¾è‘—æå‡ (x10)")}<br>
                ${assert(takenBoosted <= Math.floor(takenNormal * 0.2), "å—ä¼¤æ˜¾è‘—é™ä½ (takenMult)")}<br>
                ${assert(resBoosted.logs.some(l => l.text.includes('ç•Œç‹æ‹³')), "å‹åˆ¶è§„åˆ™æ—¥å¿—å·²æ³¨å…¥")}
            `;
        } catch (e) {
            r3.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 4: å¤šæ€ªæ¥å£ ---
        const r4 = document.getElementById('result-4');
        try {
            const multiContext = {
                player: { hp: 100, mp: 100, atk: 10, realm: "å¯»é“", subRealm: "åˆæœŸ", activeDao: "éšæœº", maxHp: 100 },
                monsters: [
                    { id: "a", hp: 0, atk: 5, name: "ç”²æœ¨æ¡©", dangerLevel: 1 },
                    { id: "b", hp: 10, atk: 5, name: "ä¹™æœ¨æ¡©", dangerLevel: 1 }
                ],
                activeTargetId: "b",
                round: 1,
                env: { mapId: "æµ‹è¯•åœº", difficulty: 1 }
            };
            const res4 = CombatEngine.run(JSON.parse(JSON.stringify(multiContext)), maxRng, { skill: { mpCost: 99999 } });
            const deltas = Array.isArray(res4.delta && res4.delta.monsters) ? res4.delta.monsters : [];
            const dA = deltas.find(d => d && d.id === 'a');
            const dB = deltas.find(d => d && d.id === 'b');
            r4.innerHTML = `
                ${assert(Array.isArray(multiContext.monsters), "context.monsters æ”¯æŒæ•°ç»„")}<br>
                ${assert(Array.isArray(deltas) && deltas.length === 2, "delta.monsters è¿”å›ä¸¤æ¡å˜æ›´")}<br>
                ${assert(dA && (Number(dA.hpDelta) || 0) === 0, "æœªé€‰ä¸­ç›®æ ‡ä¸æ‰£è¡€")}<br>
                ${assert(dB && (Number(dB.hpDelta) || 0) < 0, "é€‰ä¸­ç›®æ ‡äº§ç”Ÿæ‰£è¡€")}<br>
                ${assert(res4.result === 'win', "å¤šæ€ªèƒœåˆ©æ¡ä»¶ï¼šå…¨éƒ¨æ€ªç‰©å€’åœ°")}<br>
                ${assert(res4.logs.some(l => l && l.targetId === 'b'), "æ—¥å¿—æºå¸¦ targetId")}<br>
            `;
        } catch (e) {
            r4.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 5: çŠ¶æ€ä¸è§„åˆ™æ’ä»¶ ---
        const r5 = document.getElementById('result-5');
        try {
            const statusRule = (input) => {
                if (input && input.phase === 'player') {
                    return {
                        statusChanges: [{ target: 'player', op: 'add', status: { id: 'test_status', name: 'æµ‹è¯•çŠ¶æ€' } }],
                        logs: [{ type: 'battle', text: '>>> [çŠ¶æ€] æµ‹è¯•çŠ¶æ€å·²é™„åŠ ', tag: 'sys' }]
                    };
                }
                return null;
            };
            const skillRule = (input) => {
                if (input && input.phase === 'effect' && input.action === 'basic') {
                    return {
                        flatDamage: 5,
                        logs: [{ type: 'battle', text: '>>> [å¼ºåŒ–] æ™®æ”»é¢å¤– +5', tag: 'sys' }]
                    };
                }
                return null;
            };
            const res5 = CombatEngine.run(JSON.parse(JSON.stringify(mockContext)), maxRng, {
                skill: { mpCost: 99999 },
                rules: { status: statusRule, skill: skillRule }
            });
            const dmgLog5 = res5.logs.find(l => l && typeof l.text === 'string' && l.text.includes('é€ æˆ') && l.text.includes('ä¼¤å®³'));
            const dmg5 = dmgLog5 ? parseInt(dmgLog5.text.match(/(\d+)\s*ä¼¤å®³/)[1]) : 0;
            r5.innerHTML = `
                ${assert(Array.isArray(res5.statusChanges), "è¿”å› statusChanges æ•°ç»„")}<br>
                ${assert(res5.statusChanges.some(c => c && c.target === 'player' && c.op === 'add' && c.status && c.status.id === 'test_status'), "çŠ¶æ€å˜æ›´å·²è¾“å‡º")}<br>
                ${assert(res5.logs.some(l => l && l.text && l.text.includes('æµ‹è¯•çŠ¶æ€å·²é™„åŠ ')), "çŠ¶æ€è§„åˆ™æ—¥å¿—å·²è¾“å‡º")}<br>
                ${assert(res5.logs.some(l => l && l.text && l.text.includes('æ™®æ”»é¢å¤–')), "æŠ€èƒ½è§„åˆ™æ—¥å¿—å·²è¾“å‡º")}<br>
                ${assert(dmg5 === 16, "æŠ€èƒ½è§„åˆ™å½±å“ä¼¤å®³ï¼ˆ10+5, æœ€å¤§éšæœºï¼‰")}<br>
            `;
        } catch (e) {
            r5.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 6: Phase é€ä¼  ---
        const r6 = document.getElementById('result-6');
        try {
            const seen = [];
            const phaseAwareSkillRule = (input) => {
                if (!input || input.phase !== 'effect' || input.action !== 'basic') return null;
                seen.push(input.battlePhase || null);
                if (input.battlePhase === 'execute') {
                    return { flatDamage: 7, logs: [{ type: 'battle', text: '>>> [é˜¶æ®µ] execute åŠ æˆ +7', tag: 'sys' }] };
                }
                return null;
            };

            const ctxExecute = { ...mockContext, phase: 'execute' };
            const ctxOpening = { ...mockContext, phase: 'opening' };
            const res6a = CombatEngine.run(JSON.parse(JSON.stringify(ctxExecute)), maxRng, {
                skill: { mpCost: 99999 },
                rules: { skill: phaseAwareSkillRule }
            });
            const res6b = CombatEngine.run(JSON.parse(JSON.stringify(ctxOpening)), maxRng, {
                skill: { mpCost: 99999 },
                rules: { skill: phaseAwareSkillRule }
            });
            const dmgLog6a = res6a.logs.find(l => l && typeof l.text === 'string' && l.text.includes('é€ æˆ') && l.text.includes('ä¼¤å®³'));
            const dmgLog6b = res6b.logs.find(l => l && typeof l.text === 'string' && l.text.includes('é€ æˆ') && l.text.includes('ä¼¤å®³'));
            const dmg6a = dmgLog6a ? parseInt(dmgLog6a.text.match(/(\d+)\s*ä¼¤å®³/)[1]) : 0;
            const dmg6b = dmgLog6b ? parseInt(dmgLog6b.text.match(/(\d+)\s*ä¼¤å®³/)[1]) : 0;
            r6.innerHTML = `
                è§„åˆ™è§‚æµ‹åˆ°çš„ battlePhase: <span class="log-line">${JSON.stringify(seen)}</span><br>
                execute ä¼¤å®³: ${dmg6a}ï¼Œopening ä¼¤å®³: ${dmg6b}<br>
                ${assert(seen.includes('execute') && seen.includes('opening'), "rule è¾“å…¥å« battlePhase")}<br>
                ${assert(res6a.logs.some(l => l && l.text && l.text.includes('execute åŠ æˆ')), "execute è§¦å‘é˜¶æ®µæ€§åŠ æˆæ—¥å¿—")}<br>
                ${assert(dmg6a > dmg6b, "execute é˜¶æ®µå½±å“æˆ˜æ–—è¾“å‡º")}<br>
            `;
        } catch (e) {
            r6.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 7: äº‹ä»¶ä¸å¿ƒé­”æ¥å£ ---
        const r7 = document.getElementById('result-7');
        try {
            // å®‰å…¨è·å–å…¨å±€å¯¹è±¡ (å…¼å®¹ç›´æ¥å¼•ç”¨å’Œ window å¼•ç”¨)
            const ES = (typeof EventSystem !== 'undefined') ? EventSystem : (typeof window !== 'undefined' ? window.EventSystem : undefined);
            const HDS = (typeof HeartDemonSystem !== 'undefined') ? HeartDemonSystem : (typeof window !== 'undefined' ? window.HeartDemonSystem : undefined);

            const eventExists = ES && typeof ES.runEvent === 'function';
            const demonExists = HDS && typeof HDS.runHeartDemonEvent === 'function';
            
            let trialRes = null;
            let demonRes = null;

            if (eventExists) {
                 trialRes = ES.runEvent({ eventType: 'trial', event: { id: 't1', title: 'æµ‹è¯•äº‹ä»¶', eventType: 'trial', options: [] }, option: { id: 'o1', text: 'é€‰æ‹©', log: 'ä½ ä½œå‡ºäº†é€‰æ‹©ã€‚' }, player: mockContext.player, env: mockContext.env }, () => 0.5, {});
            }

            if (demonExists) {
                demonRes = HDS.runHeartDemonEvent({ eventType: 'heartDemon', player: { hp: 100, mp: 50, maxHp: 100, maxMp: 50, atk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é¬¼é“', statuses: [] }, env: { mapId: 'æµ‹è¯•åœº', difficulty: 1 }, behaviorStats: { windowSize: 100, battles: 100, skillUses: { 'æ§é­‚': 10 }, chainSteps: 20, statusApplies: { bleed: 5 }, dmgFromSkill: 1000, dmgFromBasic: 200 }, maxRounds: 20 }, () => 0.42, {});
            }
            
            r7.innerHTML = `
                ${assert(eventExists, "EventSystem.runEvent å­˜åœ¨")}<br>
                ${assert(demonExists, "HeartDemonSystem.runHeartDemonEvent å­˜åœ¨")}<br>
                ${assert(trialRes && typeof trialRes === 'object' && Array.isArray(trialRes.logs), "æ™®é€šäº‹ä»¶å¯è¿è¡Œå¹¶äº§ç”Ÿæ—¥å¿—")}<br>
                ${assert(demonRes && typeof demonRes === 'object' && Array.isArray(demonRes.logs), "å¿ƒé­”äº‹ä»¶å¯è¿è¡Œå¹¶äº§ç”Ÿæ—¥å¿—")}<br>
                ${assert(demonRes && demonRes.flags && demonRes.flags.heartDemonTriggered === true, "å¿ƒé­”äº‹ä»¶ flags å›ä¼ ")}<br>
            `;
        } catch (e) {
            r7.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 8: å¿ƒé­”é¢„ç®—ä¸ä¸Šé™çº¦æŸ ---
        const r8 = document.getElementById('result-8');
        try {
            const HDS = (typeof HeartDemonSystem !== 'undefined') ? HeartDemonSystem : (typeof window !== 'undefined' ? window.HeartDemonSystem : undefined);
            if (!HDS || typeof HDS.runHeartDemonEvent !== 'function') {
                r8.innerHTML = `<span class="fail">âœ˜ FAIL: æœªæ‰¾åˆ° HeartDemonSystem.runHeartDemonEvent</span>`;
            } else {
                const ctx8 = { eventType: 'heartDemon', player: { hp: 100, mp: 50, maxHp: 100, maxMp: 50, atk: 18, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é¬¼é“', statuses: [] }, env: { mapId: 'æµ‹è¯•åœº', difficulty: 1 }, behaviorStats: { windowSize: 100, battles: 100, skillUses: { 'æ§é­‚': 10 }, chainSteps: 50, statusApplies: { bleed: 20 }, dmgFromSkill: 1000, dmgFromBasic: 200 }, maxRounds: 12 };
                // ä½¿ç”¨ control æ€§æ ¼ (statuså‡ ç‡0.45) é…åˆ RNG=0.3 ç¡®ä¿è§¦å‘çŠ¶æ€ï¼ŒéªŒè¯ duration æˆªæ–­
                const opt8 = { effectLimitPerRound: 1, powerBudgetPerRound: 1, maxStatusDuration: 1, personality: 'control' };
                const res8 = HDS.runHeartDemonEvent(ctx8, () => 0.3, opt8);
                // éªŒè¯1: æ£€æŸ¥æ˜¯å¦è§¦å‘äº† debug_heartdemon æ—¥å¿—ä¸”åŒ…å« "capped" æˆ– "clipped" æˆ– "reached"
                const capped = !!(res8 && Array.isArray(res8.logs) && res8.logs.some(l => l && l.tag === 'debug_heartdemon' && (l.text.includes('capped') || l.text.includes('clipped') || l.text.includes('reached'))));
                const durOk = !!(res8 && Array.isArray(res8.statusChanges) && res8.statusChanges.some(ch => ch && ch.status && typeof ch.status.duration === 'number' && ch.status.duration <= 1));
                
                // Debug info if failed
                const statusDebug = res8 && res8.statusChanges ? JSON.stringify(res8.statusChanges.map(c => c.status)) : 'none';
                
                r8.innerHTML = `
                    ${assert(!!res8, "å¿ƒé­”äº‹ä»¶å¯è¿è¡Œ")}<br>
                    ${assert(capped, "è¶…é™æ—¶äº§ç”Ÿ heartDemon_capped æ—¥å¿—")}<br>
                    ${assert(durOk, "çŠ¶æ€ duration è¢«å¼ºåˆ¶ä¸Šé™ (<=1)")} <span style="font-size:0.8em;color:#666">(generated: ${statusDebug})</span><br>
                `;
            }
        } catch (e) {
            r8.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 9: äº‹ä»¶é€‰é¡¹ç™½åå•æ ¡éªŒ ---
        const r9 = document.getElementById('result-9');
        try {
            const ES = (typeof EventSystem !== 'undefined') ? EventSystem : (typeof window !== 'undefined' ? window.EventSystem : undefined);
            if (!ES || typeof ES.runEvent !== 'function') {
                r9.innerHTML = `<span class="fail">âœ˜ FAIL: æœªæ‰¾åˆ° EventSystem.runEvent</span>`;
            } else {
                const badOption = { id: 'o_bad', text: 'ä¸åˆæ³•é€‰é¡¹', log: 'ä¸åº”é€šè¿‡', if: true, delta: { playerHp: 1 } };
                const res9 = ES.runEvent({ eventType: 'trial', event: { id: 't9', title: 'ç™½åå•æµ‹è¯•', eventType: 'trial', options: [] }, option: badOption, player: mockContext.player, env: mockContext.env }, () => 0.5, {});
                const rejected = !!(res9 && res9.result === 'failure' && res9.flags && res9.flags.invalidOption);
                const hasInvalidLog = !!(res9 && Array.isArray(res9.logs) && res9.logs.some(l => l && l.tag === 'event_invalid'));
                r9.innerHTML = `
                    ${assert(rejected, "åŒ…å«ç¦æ­¢å­—æ®µçš„ option è¢«æ‹’ç»")}<br>
                    ${assert(hasInvalidLog, "äº§å‡º event_invalid æ—¥å¿—")}<br>
                `;
            }
        } catch (e) {
            r9.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        // --- æµ‹è¯• 10: V2 æ¶æ„ç‰¹æ€§ ---
        const r10 = document.getElementById('result-10');
        try {
            // 10.1 Safety Layer: Illegal Delta Rejection
            let safetyPass = false;
            let safetyLog = false;
            if (typeof gameState !== 'undefined' && typeof gameState.applyPlayerDelta === 'function') {
                const initialHp = gameState.hp;
                // Capture console.error temporarily
                const originalError = console.error;
                let errorCalled = false;
                console.error = (...args) => { errorCalled = true; originalError.apply(console, args); };
                
                // Attempt illegal update
                gameState.applyPlayerDelta({ playerHp: NaN });
                
                console.error = originalError; // Restore
                
                safetyPass = (gameState.hp === initialHp); // State should not change
                safetyLog = errorCalled; // Should trigger error log
            }

            // 10.2 Declarative Rules
            let ruleMetaPass = false;
            if (typeof Rules !== 'undefined' && Rules.explorationRecovery && Rules.explorationRecovery.ruleMeta) {
                const meta = Rules.explorationRecovery.ruleMeta;
                ruleMetaPass = Array.isArray(meta.inputs) && Array.isArray(meta.outputs) && Array.isArray(meta.guarantees);
            }

            // 10.3 HeartDemon Debug Logs
            let debugLogPass = false;
            const HDS = (typeof HeartDemonSystem !== 'undefined') ? HeartDemonSystem : (typeof window !== 'undefined' ? window.HeartDemonSystem : undefined);
            if (HDS && typeof HDS.runHeartDemonEvent === 'function') {
                 // Run a scenario that triggers budget usage (high complexity)
                 const ctxDebug = { 
                     eventType: 'heartDemon', 
                     player: { hp: 100, mp: 50, maxHp: 100, maxMp: 50, atk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é¬¼é“', statuses: [] }, 
                     env: { mapId: 'DebugMap', difficulty: 1 }, 
                     behaviorStats: { windowSize: 100, battles: 100, skillUses: { 'æ§é­‚': 10 }, chainSteps: 50, statusApplies: { bleed: 20 }, dmgFromSkill: 1000, dmgFromBasic: 200 }, 
                     maxRounds: 5 
                 };
                 const resDebug = HDS.runHeartDemonEvent(ctxDebug, () => 0.5, { effectLimitPerRound: 5 });
                 // Check for logs with specific debug tag
                 if (resDebug && resDebug.logs) {
                     debugLogPass = resDebug.logs.some(l => l.tag === 'debug_heartdemon');
                 }
            }

            r10.innerHTML = `
                ${assert(safetyPass, "applyPlayerDelta æ‹’ç» NaN æ›´æ–° (çŠ¶æ€æœªå˜)")}<br>
                ${assert(safetyLog, "è§¦å‘éæ³•æ•°å€¼æ‹¦æˆªæ—¥å¿— (console.error)")}<br>
                ${assert(ruleMetaPass, "Rules åŒ…å«å£°æ˜å¼å…ƒæ•°æ® (ruleMeta)")}<br>
                ${assert(debugLogPass, "å¿ƒé­”äº‹ä»¶äº§ç”Ÿ debug_heartdemon æ—¥å¿—")}<br>
            `;
        } catch (e) {
             r10.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
             console.error(e);
        }

        // --- æµ‹è¯• 11: å­˜æ¡£ä¸€è‡´æ€§ ---
        const r11 = document.getElementById('result-11');
        try {
            if (typeof gameState !== 'undefined' && typeof gameState.verifyConsistency === 'function') {
                const consistent = gameState.verifyConsistency(5);
                r11.innerHTML = `
                    ${assert(consistent, "5 å›åˆå›æ”¾çŠ¶æ€å®Œå…¨ä¸€è‡´")}<br>
                `;
            } else {
                r11.innerHTML = `<span class="fail">âœ˜ FAIL: æœªæ‰¾åˆ° verifyConsistency æ–¹æ³•</span>`;
            }
        } catch (e) {
             r11.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
             console.error(e);
        }

        const r13 = document.getElementById('result-13');
        try {
            const HDS = (typeof HeartDemonSystem !== 'undefined') ? HeartDemonSystem : (typeof window !== 'undefined' ? window.HeartDemonSystem : undefined);
            if (!HDS || typeof HDS.runHeartDemonEvent !== 'function') {
                r13.innerHTML = `<span class="fail">âœ˜ FAIL: æœªæ‰¾åˆ° HeartDemonSystem.runHeartDemonEvent</span>`;
            } else {
                const rng03 = () => 0.3;
                const ctxBase = {
                    eventType: 'heartDemon',
                    player: { hp: 100, mp: 50, maxHp: 100, maxMp: 50, atk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é¬¼é“', statuses: [] },
                    env: { mapId: 'DebugMap', difficulty: 1 },
                    behaviorStats: { windowSize: 100, battles: 100, skillUses: { 'æ§é­‚': 10 }, chainSteps: 50, statusApplies: { bleed: 20 }, dmgFromSkill: 1000, dmgFromBasic: 200 },
                    maxRounds: 4
                };
                const commonOpts = { effectLimitPerRound: 10, maxStatusDuration: 1, powerBudgetPerRound: 40 };
                const resAgg = HDS.runHeartDemonEvent({ ...ctxBase, personality: 'aggressive' }, rng03, commonOpts);
                const resCtrl = HDS.runHeartDemonEvent({ ...ctxBase, personality: 'control' }, rng03, commonOpts);
                const resDrain = HDS.runHeartDemonEvent({ ...ctxBase, personality: 'drain' }, rng03, commonOpts);

                const scAgg = Array.isArray(resAgg.statusChanges) ? resAgg.statusChanges.length : 0;
                const scCtrl = Array.isArray(resCtrl.statusChanges) ? resCtrl.statusChanges.length : 0;
                const hasDrainMp = Array.isArray(resDrain.effects) && resDrain.effects.some(e => e && e.type === 'mp' && (Number(e.value) || 0) < 0);
                const hasAggStatus = Array.isArray(resAgg.statusChanges) && resAgg.statusChanges.length > 0;

                r13.innerHTML = `
                    ${assert(scCtrl > scAgg, "control æ€§æ ¼æ›´åå‘æ–½åŠ çŠ¶æ€")}<br>
                    ${assert(!hasAggStatus, "aggressive æ€§æ ¼æ›´åå‘ç›´æ¥ä¼¤å®³")}<br>
                    ${assert(hasDrainMp, "drain æ€§æ ¼æ›´åå‘æ¶ˆè€—çµåŠ›")}<br>
                `;
            }
        } catch (e) {
            r13.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        const panel12 = document.getElementById('rules-panel');
        try {
            const hasRules = (typeof Rules !== 'undefined' && Rules && typeof Rules === 'object');
            const registry = (typeof window !== 'undefined' && window.RulesRegistry && typeof window.RulesRegistry === 'object') ? window.RulesRegistry : {};
            const names = Object.keys(registry).length ? Object.keys(registry) : (hasRules ? Object.keys(Rules).filter(k => typeof Rules[k] === 'function') : []);

            if (!names.length) {
                panel12.innerHTML = `<span class="fail">âœ˜ FAIL: æœªæ‰¾åˆ°å¯è§†åŒ–è§„åˆ™ï¼ˆRulesRegistry / Rules ä¸ºç©ºï¼‰</span>`;
            } else {
                if (typeof window !== 'undefined' && typeof window.DEBUG_META === 'undefined') window.DEBUG_META = false;

                const wrap = document.createElement('div');
                wrap.style.display = 'grid';
                wrap.style.gridTemplateColumns = '220px 1fr';
                wrap.style.gap = '12px';

                const left = document.createElement('div');
                const right = document.createElement('div');

                const dbgLine = document.createElement('div');
                dbgLine.style.marginBottom = '8px';
                const dbg = document.createElement('input');
                dbg.type = 'checkbox';
                dbg.checked = (typeof window !== 'undefined' && window.DEBUG_META === true);
                dbg.onchange = () => { if (typeof window !== 'undefined') window.DEBUG_META = dbg.checked; };
                const dbgLabel = document.createElement('label');
                dbgLabel.style.marginLeft = '6px';
                dbgLabel.textContent = 'æ˜¾ç¤ºæ—¥å¿—è¿½è¸ªä¿¡æ¯ (DEBUG_META)';
                dbgLine.appendChild(dbg);
                dbgLine.appendChild(dbgLabel);

                const selLabel = document.createElement('div');
                selLabel.style.fontWeight = 'bold';
                selLabel.style.marginBottom = '6px';
                selLabel.textContent = 'é€‰æ‹©è§„åˆ™';

                const select = document.createElement('select');
                select.style.width = '100%';
                select.style.padding = '6px';
                names.forEach(n => {
                    const opt = document.createElement('option');
                    opt.value = n;
                    opt.textContent = n;
                    select.appendChild(opt);
                });

                const cfgTitle = document.createElement('div');
                cfgTitle.style.fontWeight = 'bold';
                cfgTitle.style.margin = '10px 0 6px';
                cfgTitle.textContent = 'RulesConfig (JSON)';

                const cfgArea = document.createElement('textarea');
                cfgArea.style.width = '100%';
                cfgArea.style.height = '160px';
                cfgArea.style.fontFamily = 'monospace';
                cfgArea.style.fontSize = '12px';
                cfgArea.style.padding = '6px';

                const btnRow = document.createElement('div');
                btnRow.style.display = 'flex';
                btnRow.style.gap = '8px';
                btnRow.style.marginTop = '6px';

                const applyBtn = document.createElement('button');
                applyBtn.textContent = 'åº”ç”¨é…ç½®';
                applyBtn.style.padding = '6px 10px';
                const runBtn = document.createElement('button');
                runBtn.textContent = 'è¯•è¿è¡Œä¸€æ¬¡';
                runBtn.style.padding = '6px 10px';
                btnRow.appendChild(applyBtn);
                btnRow.appendChild(runBtn);

                const msg = document.createElement('div');
                msg.style.marginTop = '6px';
                msg.style.fontSize = '12px';

                left.appendChild(dbgLine);
                left.appendChild(selLabel);
                left.appendChild(select);
                left.appendChild(cfgTitle);
                left.appendChild(cfgArea);
                left.appendChild(btnRow);
                left.appendChild(msg);

                const metaTitle = document.createElement('div');
                metaTitle.style.fontWeight = 'bold';
                metaTitle.style.marginBottom = '6px';
                metaTitle.textContent = 'ruleMeta';
                const metaPre = document.createElement('pre');
                metaPre.style.margin = '0 0 10px';
                metaPre.style.padding = '10px';
                metaPre.style.background = '#0f0f0f';
                metaPre.style.color = '#e6e6e6';
                metaPre.style.borderRadius = '4px';
                metaPre.style.overflowX = 'auto';

                const rangeTitle = document.createElement('div');
                rangeTitle.style.fontWeight = 'bold';
                rangeTitle.style.margin = '10px 0 6px';
                rangeTitle.textContent = 'æ¨¡æ‹Ÿè¾“å…¥å‚æ•° (JSON å¯ç¼–è¾‘)';
                const rangeArea = document.createElement('textarea');
                rangeArea.style.width = '100%';
                rangeArea.style.height = '120px';
                rangeArea.style.fontFamily = 'monospace';
                rangeArea.style.fontSize = '12px';
                rangeArea.style.padding = '6px';

                const outTitle = document.createElement('div');
                outTitle.style.fontWeight = 'bold';
                outTitle.style.margin = '10px 0 6px';
                outTitle.textContent = 'è¯•è¿è¡Œè¾“å‡º';
                const outPre = document.createElement('pre');
                outPre.style.margin = '0';
                outPre.style.padding = '10px';
                outPre.style.background = '#0f0f0f';
                outPre.style.color = '#e6e6e6';
                outPre.style.borderRadius = '4px';
                outPre.style.overflowX = 'auto';

                right.appendChild(metaTitle);
                right.appendChild(metaPre);
                right.appendChild(rangeTitle);
                right.appendChild(rangeArea);
                right.appendChild(outTitle);
                right.appendChild(outPre);

                wrap.appendChild(left);
                wrap.appendChild(right);

                const safeJson = (obj) => {
                    try { return JSON.stringify(obj, null, 2); } catch (e) { return String(obj); }
                };

                const getCfg = () => (typeof window !== 'undefined' && window.RulesConfig && typeof window.RulesConfig === 'object') ? window.RulesConfig : {};

                const buildRanges = (inputs) => {
                    const gs = (typeof gameState !== 'undefined' && gameState && typeof gameState === 'object') ? gameState : {};
                    const out = {};
                    (inputs || []).forEach(k => {
                        if (k === 'hp') out.hp = { value: gs.hp, range: [0, gs.maxHp] };
                        else if (k === 'mp') out.mp = { value: gs.mp, range: [0, gs.maxMp] };
                        else if (k === 'maxHp') out.maxHp = { value: gs.maxHp, range: [1, 999999] };
                        else if (k === 'maxMp') out.maxMp = { value: gs.maxMp, range: [0, 999999] };
                        else if (k === 'exp') out.exp = { value: gs.exp, range: [0, gs.maxExp] };
                        else if (k === 'maxExp') out.maxExp = { value: gs.maxExp, range: [0, 999999] };
                        else if (k === 'location') out.location = { value: gs.currentMap && gs.currentMap.id ? gs.currentMap.id : null };
                        else if (k === 'map') out.map = { value: gs.currentMap && gs.currentMap.id ? { id: gs.currentMap.id, env: gs.currentMap.env, drops: gs.currentMap.drops } : null };
                        else out[k] = { value: gs[k] };
                    });
                    return out;
                };

                const buildInput = (ruleName, inputs) => {
                    const gs = (typeof gameState !== 'undefined' && gameState && typeof gameState === 'object') ? gameState : {};
                    const input = {};
                    (inputs || []).forEach(k => {
                        if (k === 'hp') input.hp = Number(gs.hp) || 0;
                        else if (k === 'mp') input.mp = Number(gs.mp) || 0;
                        else if (k === 'maxHp') input.maxHp = Number(gs.maxHp) || 100;
                        else if (k === 'maxMp') input.maxMp = Number(gs.maxMp) || 0;
                        else if (k === 'exp') input.exp = Number(gs.exp) || 0;
                        else if (k === 'maxExp') input.maxExp = Number(gs.maxExp) || 100;
                        else if (k === 'location') input.location = gs.currentMap && gs.currentMap.id ? gs.currentMap.id : null;
                        else if (k === 'map') input.map = gs.currentMap || { id: 'DebugMap', env: 'default', drops: ['çµçŸ³'] };
                        else if (k === 'monsters') input.monsters = [{ name: 'æœ¨æ¡©', exp: 10 }];
                        else input[k] = gs[k];
                    });
                    return input;
                };

                const refresh = () => {
                    const name = select.value;
                    const entry = registry && registry[name] ? registry[name] : null;
                    const fn = hasRules ? Rules[name] : null;
                    const ruleMeta = entry && entry.ruleMeta ? entry.ruleMeta : (fn && fn.ruleMeta ? fn.ruleMeta : null);
                    metaPre.textContent = safeJson(ruleMeta || {});

                    const inputs = ruleMeta && Array.isArray(ruleMeta.inputs) ? ruleMeta.inputs : [];
                    // rangePre.textContent = safeJson(buildRanges(inputs));
                    rangeArea.value = safeJson(buildInput(name, inputs));

                    const cfg = getCfg();
                    cfgArea.value = safeJson(cfg);
                    msg.textContent = '';
                    outPre.textContent = '';
                };

                select.onchange = refresh;
                applyBtn.onclick = () => {
                    try {
                        const v = JSON.parse(cfgArea.value || '{}');
                        if (typeof window !== 'undefined') window.RulesConfig = v;
                        msg.style.color = '#27ae60';
                        msg.textContent = 'é…ç½®å·²åº”ç”¨ã€‚';
                        refresh();
                    } catch (e) {
                        msg.style.color = '#c0392b';
                        msg.textContent = `é…ç½®è§£æå¤±è´¥ï¼š${e && e.message ? e.message : 'unknown'}`;
                    }
                };
                runBtn.onclick = () => {
                    const name = select.value;
                    const entry = registry && registry[name] ? registry[name] : null;
                    const fn = hasRules ? Rules[name] : null;
                    // const ruleMeta = entry && entry.ruleMeta ? entry.ruleMeta : (fn && fn.ruleMeta ? fn.ruleMeta : null);
                    // const inputs = ruleMeta && Array.isArray(ruleMeta.inputs) ? ruleMeta.inputs : [];
                    
                    let input = {};
                    try {
                        input = JSON.parse(rangeArea.value);
                    } catch (e) {
                        outPre.textContent = `è¾“å…¥å‚æ•° JSON è§£æå¤±è´¥: ${e.message}`;
                        return;
                    }

                    try {
                        let out = null;
                        if (typeof fn === 'function') {
                            if (fn.length >= 2) out = fn(input, () => 0.5);
                            else out = fn(input);
                        }
                        outPre.textContent = safeJson(out);
                    } catch (e) {
                        outPre.textContent = `è¿è¡Œæ—¶é”™è¯¯ï¼š${e && e.message ? e.message : 'unknown'}`;
                    }
                };

                panel12.innerHTML = '';
                panel12.appendChild(wrap);
                refresh();
            }
        } catch (e) {
            panel12.innerHTML = `<span class="fail">ğŸ’¥ é¢æ¿åˆå§‹åŒ–é”™è¯¯: ${e.message}</span>`;
            console.error(e);
        }

        const r14 = document.getElementById('result-14');
        const tl14 = document.getElementById('timeline-14');
        try {
            const hasStory = (typeof gameState !== 'undefined' && gameState && typeof gameState.applyStoryUpdate === 'function');
            const hasEventSystem = (typeof EventSystem !== 'undefined' && EventSystem && typeof EventSystem.runEvent === 'function');
            const hasStoryTick = (typeof Rules !== 'undefined' && Rules && typeof Rules.storyTick === 'function');
            const hasGetEvent = (typeof Rules !== 'undefined' && Rules && typeof Rules.getEventById === 'function');

            const safeHash = () => {
                if (!gameState || typeof gameState.stableStringify !== 'function' || typeof gameState.hashFNV1a32 !== 'function') return null;
                return gameState.hashFNV1a32(gameState.stableStringify({
                    hp: gameState.hp,
                    mp: gameState.mp,
                    exp: gameState.exp,
                    maxHp: gameState.maxHp,
                    maxMp: gameState.maxMp,
                    story: gameState.story
                }));
            };

            const runStorySim = (seed) => {
                const rng = (typeof gameState.createSeededRng === 'function') ? gameState.createSeededRng(seed) : (() => 0.5);
                gameState.rng = rng;
                gameState._deltaSeq = 0;
                gameState.hp = 100;
                gameState.maxHp = 100;
                gameState.mp = 50;
                gameState.maxMp = 50;
                gameState.exp = 0;
                gameState.realm = 'å¯»é“';
                gameState.stage = 'ç„é—¨';
                gameState.currentMap = (typeof GameData !== 'undefined' && GameData.mapConfig && GameData.mapConfig['å°ä¹‰å±¯'])
                    ? GameData.mapConfig['å°ä¹‰å±¯']
                    : (typeof GameData !== 'undefined' && GameData.mapConfig ? GameData.mapConfig[Object.keys(GameData.mapConfig)[0]] : null);
                gameState.story = { chainId: 'windchain', day: 1, step: 0, tick: 0, nextAtTick: 1, nextEventId: 'story_windchain_d1_01', flags: {}, completed: false };

                const tickPerDay = 10;
                const totalTicks = tickPerDay * 5;
                const history = [];

                for (let t = 0; t < totalTicks; t++) {
                    const tickRes = Rules.storyTick({ story: gameState.story });
                    if (tickRes && tickRes.storyUpdate && typeof tickRes.storyUpdate.tick === 'number') {
                        gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                    }

                    if (!tickRes || tickRes.trigger !== true || !tickRes.eventId) continue;

                    const event = Rules.getEventById(tickRes.eventId);
                    if (!event || !Array.isArray(event.options) || !event.options.length) continue;
                    const idx = Math.max(0, Math.min(event.options.length - 1, Math.floor(gameState.rng() * event.options.length)));
                    const option = event.options[idx];

                    const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('Story') : `Story#${t + 1}`;
                    const res = EventSystem.runEvent({ eventType: event.eventType, event, option, deltaKey }, gameState.rng, {});
                    if (res && typeof gameState.applyEventResult === 'function') gameState.applyEventResult(res);

                    history.push({
                        tick: gameState.story && typeof gameState.story.tick === 'number' ? gameState.story.tick : null,
                        day: gameState.story && typeof gameState.story.day === 'number' ? gameState.story.day : null,
                        step: gameState.story && typeof gameState.story.step === 'number' ? gameState.story.step : null,
                        eventId: event.id,
                        title: event.title,
                        optionId: option && option.id ? option.id : null,
                        optionText: option && option.text ? option.text : null,
                        deltaKey,
                        delta: res && res.delta ? res.delta : null,
                        storyUpdate: res && res.flags && res.flags.story ? res.flags.story : null,
                        hash: safeHash()
                    });
                }

                return history;
            };

            const canRun = hasStory && hasEventSystem && hasStoryTick && hasGetEvent;
            if (!canRun) {
                r14.innerHTML = `
                    ${assert(hasStory, "gameState.applyStoryUpdate å­˜åœ¨")}<br>
                    ${assert(hasEventSystem, "EventSystem.runEvent å­˜åœ¨")}<br>
                    ${assert(hasStoryTick, "Rules.storyTick å­˜åœ¨")}<br>
                    ${assert(hasGetEvent, "Rules.getEventById å­˜åœ¨")}<br>
                `;
                tl14.innerHTML = '';
            } else {
                const seed = 20260131;
                const a = runStorySim(seed);
                const b = runStorySim(seed);
                const same = JSON.stringify(a) === JSON.stringify(b);
                const last = a.length ? a[a.length - 1] : null;

                r14.innerHTML = `
                    ${assert(a.length >= 5, "5 å¤©å†…è‡³å°‘è§¦å‘ 5 æ¬¡å™äº‹äº‹ä»¶")}<br>
                    ${assert(same, "åŒ seed å›æ”¾è¾“å‡ºä¸€è‡´ï¼ˆä¸å« exportedAtï¼‰")}<br>
                    è§¦å‘æ¬¡æ•°ï¼š${a.length}ï¼›æœ€ç»ˆ hashï¼š<span class="log-line">${last ? last.hash : 'N/A'}</span><br>
                `;

                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                const head = document.createElement('tr');
                ['#', 'day', 'tick', 'event', 'option', 'deltaKey', 'delta', 'hash'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    th.style.textAlign = 'left';
                    th.style.padding = '6px';
                    th.style.borderBottom = '1px solid #ddd';
                    head.appendChild(th);
                });
                table.appendChild(head);

                a.forEach((row, i) => {
                    const tr = document.createElement('tr');
                    const cells = [
                        String(i + 1),
                        String(row.day),
                        String(row.tick),
                        `${row.eventId} Â· ${row.title}`,
                        `${row.optionId} Â· ${row.optionText}`,
                        row.deltaKey,
                        JSON.stringify(row.delta),
                        row.hash
                    ];
                    cells.forEach((c, idx) => {
                        const td = document.createElement('td');
                        td.style.padding = '6px';
                        td.style.borderBottom = '1px dashed #eee';
                        if (idx === 5 || idx === 7) td.style.fontFamily = 'monospace';
                        td.textContent = c;
                        tr.appendChild(td);
                    });
                    table.appendChild(tr);
                });

                const details = document.createElement('details');
                const summary = document.createElement('summary');
                summary.textContent = 'å±•å¼€æŸ¥çœ‹ï¼šæ¯æ­¥ storyUpdate';
                details.appendChild(summary);
                const pre = document.createElement('pre');
                pre.style.margin = '8px 0 0';
                pre.style.padding = '10px';
                pre.style.background = '#0f0f0f';
                pre.style.color = '#e6e6e6';
                pre.style.borderRadius = '4px';
                pre.style.overflowX = 'auto';
                pre.textContent = JSON.stringify(a.map(x => ({ day: x.day, tick: x.tick, eventId: x.eventId, optionId: x.optionId, storyUpdate: x.storyUpdate })), null, 2);
                details.appendChild(pre);

                tl14.innerHTML = '';
                tl14.appendChild(table);
                tl14.appendChild(details);
            }
        } catch (e) {
            r14.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            tl14.innerHTML = '';
            console.error(e);
        }

        const r15 = document.getElementById('result-15');
        const tl15 = document.getElementById('timeline-15');
        try {
            const hasStory = (typeof gameState !== 'undefined' && gameState && typeof gameState.applyStoryUpdate === 'function');
            const hasEventSystem = (typeof EventSystem !== 'undefined' && EventSystem && typeof EventSystem.runEvent === 'function');
            const hasStoryTick = (typeof Rules !== 'undefined' && Rules && typeof Rules.storyTick === 'function');
            const hasGetEvent = (typeof Rules !== 'undefined' && Rules && typeof Rules.getEventById === 'function');

            const canRun = hasStory && hasEventSystem && hasStoryTick && hasGetEvent;
            const startEvent = canRun ? Rules.getEventById('story_mindfracture_d1_01') : null;
            const hasMindfracture = !!(startEvent && startEvent.id === 'story_mindfracture_d1_01');

            const safeHash = () => {
                if (!gameState || typeof gameState.stableStringify !== 'function' || typeof gameState.hashFNV1a32 !== 'function') return null;
                return gameState.hashFNV1a32(gameState.stableStringify({
                    hp: gameState.hp,
                    mp: gameState.mp,
                    exp: gameState.exp,
                    maxHp: gameState.maxHp,
                    maxMp: gameState.maxMp,
                    story: gameState.story,
                    inventory: gameState.inventory
                }));
            };

            const pickOption = (event, scenario) => {
                if (!event || !Array.isArray(event.options) || !event.options.length) return null;
                const byId = (id) => event.options.find(o => o && o.id === id) || event.options[0];
                if (event.id === 'story_mindfracture_d1_01') return byId('endure');
                if (event.id === 'story_mindfracture_d2_01') return byId('continue');
                if (event.id === 'story_mindfracture_d3_01') return byId('ignore');
                if (event.id === 'story_mindfracture_d4_01') return byId('continue');
                if (event.id === 'story_mindfracture_d5_01') {
                    const s = scenario && typeof scenario === 'object' ? scenario : {};
                    const d5 = (typeof s.d5Choice === 'string' && s.d5Choice.trim()) ? s.d5Choice.trim() : 'face_demon';
                    return byId(d5);
                }
                return event.options[0];
            };

            const runMindSim = (seed, scenario) => {
                const baseRng = (typeof gameState.createSeededRng === 'function') ? gameState.createSeededRng(seed) : (() => 0.5);
                const s = scenario && typeof scenario === 'object' ? scenario : {};
                const seq = Array.isArray(s.rngSeq) ? s.rngSeq.map(Number).filter(x => Number.isFinite(x) && x >= 0 && x <= 1) : null;
                let seqIdx = 0;
                const rng = seq && seq.length
                    ? (() => {
                        return () => {
                            if (seqIdx < seq.length) return seq[seqIdx++];
                            return baseRng();
                        };
                    })()
                    : baseRng;
                gameState.rng = rng;
                gameState._deltaSeq = 0;
                const init = s.init && typeof s.init === 'object' ? s.init : {};
                gameState.hp = Number.isFinite(Number(init.hp)) ? Number(init.hp) : 140;
                gameState.maxHp = Number.isFinite(Number(init.maxHp)) ? Number(init.maxHp) : gameState.hp;
                gameState.mp = Number.isFinite(Number(init.mp)) ? Number(init.mp) : 80;
                gameState.maxMp = Number.isFinite(Number(init.maxMp)) ? Number(init.maxMp) : gameState.mp;
                gameState.exp = 0;
                gameState.realm = 'å¯»é“';
                gameState.stage = 'ç„é—¨';
                gameState.inventory = {};
                gameState.currentMap = (typeof GameData !== 'undefined' && GameData.mapConfig && GameData.mapConfig['å°ä¹‰å±¯'])
                    ? GameData.mapConfig['å°ä¹‰å±¯']
                    : (typeof GameData !== 'undefined' && GameData.mapConfig ? GameData.mapConfig[Object.keys(GameData.mapConfig)[0]] : null);

                const initialFlags = (s.initialFlags && typeof s.initialFlags === 'object') ? s.initialFlags : {};
                gameState.story = { chainId: 'mindfracture', day: 1, step: 0, tick: 0, nextAtTick: 1, nextEventId: 'story_mindfracture_d1_01', flags: { ...initialFlags }, completed: false };

                const tickPerDay = 10;
                const totalTicks = tickPerDay * 6;
                const history = [];

                for (let t = 0; t < totalTicks; t++) {
                    const tickRes = Rules.storyTick({ story: gameState.story });
                    if (tickRes && tickRes.storyUpdate && typeof tickRes.storyUpdate.tick === 'number') {
                        gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                    }

                    if (!tickRes || tickRes.trigger !== true || !tickRes.eventId) continue;

                    const event = Rules.getEventById(tickRes.eventId);
                    if (!event) continue;
                    const option = pickOption(event, s);
                    if (!option) continue;

                    const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('Mindfracture') : `Mindfracture#${t + 1}`;
                    const res = EventSystem.runEvent({
                        eventType: event.eventType,
                        event,
                        option,
                        deltaKey,
                        player: { hp: gameState.hp, mp: gameState.mp, maxHp: gameState.maxHp, maxMp: gameState.maxMp, atk: 14, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'éšæœº', statuses: [] },
                        env: { mapId: 'å¿ƒå¢ƒ', difficulty: 2 },
                        behaviorStats: { windowSize: 100, battles: 30, skillUses: { 'æ§é­‚': 3 }, chainSteps: 30, statusApplies: { fear: 1 }, dmgFromSkill: 120, dmgFromBasic: 80 }
                    }, gameState.rng, {});

                    if (res && typeof gameState.applyEventResult === 'function') gameState.applyEventResult(res);

                    const sf = gameState.story && gameState.story.flags && typeof gameState.story.flags === 'object' ? gameState.story.flags : {};
                    const demonSeen = !!(res && Array.isArray(res.logs) && res.logs.some(l => l && (l.tag === 'debug_heartdemon' || l.tag === 'demon_atk' || l.tag === 'heartDemon_capped')));
                    const hasMfNoise = Object.prototype.hasOwnProperty.call(sf, 'mf_noise');
                    const mfNoise = hasMfNoise ? (sf.mf_noise === true) : (sf.mind_noise === true);
                    const hasMfStrain = Object.prototype.hasOwnProperty.call(sf, 'mf_strain');
                    const mfStrain = (() => {
                        const v = Number(hasMfStrain ? sf.mf_strain : sf.mind_strain);
                        if (!Number.isFinite(v)) return 0;
                        return Math.max(0, Math.min(5, Math.floor(v)));
                    })();
                    const af = (typeof sf.mf_aftermath === 'string' && sf.mf_aftermath.trim()) ? sf.mf_aftermath.trim() : null;

                    history.push({
                        tick: gameState.story && typeof gameState.story.tick === 'number' ? gameState.story.tick : null,
                        day: gameState.story && typeof gameState.story.day === 'number' ? gameState.story.day : null,
                        eventId: event.id,
                        optionId: option && option.id ? option.id : null,
                        optionText: option && option.text ? option.text : null,
                        mf_noise: mfNoise === true,
                        mf_strain: mfStrain,
                        mf_interference: sf.mf_interference === true,
                        mf_pressure: sf.mf_pressure === true,
                        mf_resolved: sf.mf_resolved || null,
                        mf_aftermath: af,
                        demonSeen,
                        deltaKey,
                        hash: safeHash()
                    });
                }
                return history;
            };

            if (!canRun || !hasMindfracture) {
                r15.innerHTML = `
                    ${assert(canRun, "åŸºç¡€ Story / Event / Rules æ¥å£å¯è¿è¡Œ")}<br>
                    ${assert(hasMindfracture, "å·²åŠ è½½ mindfracture äº‹ä»¶é“¾ (story_mindfracture_d1_01)")}<br>
                `;
                tl15.innerHTML = '';
            } else {
                const seed = 20260131;
                const scenario = { d5Choice: 'face_demon', init: { hp: 2000, maxHp: 2000, mp: 300, maxMp: 300 } };
                const a = runMindSim(seed, scenario);
                const b = runMindSim(seed, scenario);
                const same = JSON.stringify(a) === JSON.stringify(b);

                const sawDay2 = a.some(x => x.eventId === 'story_mindfracture_d2_01' && x.mf_interference);
                const sawDay3Strain = a.some(x => x.eventId === 'story_mindfracture_d3_01' && x.mf_strain >= 1);
                const sawDay4 = a.some(x => x.eventId === 'story_mindfracture_d4_01' && x.mf_pressure);
                const day5 = a.find(x => x.eventId === 'story_mindfracture_d5_01');
                const cleared = (() => {
                    const last = a.length ? a[a.length - 1] : null;
                    if (!last) return false;
                    return last.mf_noise === false && Number(last.mf_strain) === 0 && !!last.mf_resolved;
                })();
                const tempered = (() => {
                    const last = a.length ? a[a.length - 1] : null;
                    if (!last) return false;
                    return last.mf_aftermath === 'tempered';
                })();

                const scarredRun = runMindSim(seed, { d5Choice: 'force_breakthrough', rngSeq: [0.0] });
                const scarred = (() => {
                    const last = scarredRun.length ? scarredRun[scarredRun.length - 1] : null;
                    return !!(last && last.mf_aftermath === 'scarred');
                })();

                const brokenRun = runMindSim(seed, { d5Choice: 'force_breakthrough', rngSeq: [0.99], init: { hp: 60, maxHp: 60, mp: 80, maxMp: 80 } });
                const broken = (() => {
                    const last = brokenRun.length ? brokenRun[brokenRun.length - 1] : null;
                    return !!(last && last.mf_aftermath === 'broken');
                })();

                const stickyRun = runMindSim(seed, { d5Choice: 'force_breakthrough', rngSeq: [0.0], initialFlags: { mf_aftermath: 'tempered' } });
                const sticky = (() => {
                    const last = stickyRun.length ? stickyRun[stickyRun.length - 1] : null;
                    return !!(last && last.mf_aftermath === 'tempered');
                })();

                r15.innerHTML = `
                    ${assert(a.length >= 5, "5 å¤©å†…è§¦å‘ mindfracture å™äº‹äº‹ä»¶")}<br>
                    ${assert(same, "åŒ seed å›æ”¾ä¸€è‡´")}<br>
                    ${assert(sawDay2, "Day2 å¹²æ‰°æ——æ ‡ç”Ÿæ•ˆ (mf_interference)")}<br>
                    ${assert(sawDay3Strain, "Day3 é€‰æ‹©å¯¼è‡´ mf_strain å åŠ ")}<br>
                    ${assert(sawDay4, "Day4 å‹åŠ›æ——æ ‡ç”Ÿæ•ˆ (mf_pressure)")}<br>
                    ${assert(!!(day5 && day5.demonSeen), "Day5 è§¦å‘å¿ƒé­”ç»“ç®—æ—¥å¿—")}<br>
                    ${assert(cleared, "Day5 ç»“ç®—åæ¸…ç†ä¸´æ—¶çŠ¶æ€å¹¶å†™å…¥ mf_resolved")}<br>
                    ${assert(tempered, "ç›´é¢å¿ƒé­”èƒœ/partial å†™å…¥ mf_aftermath=tempered")}<br>
                    ${assert(scarred, "å¼ºè¡Œçªç ´æˆåŠŸå†™å…¥ mf_aftermath=scarred")}<br>
                    ${assert(broken, "å¼ºè¡Œçªç ´å¤±è´¥å†™å…¥ mf_aftermath=broken")}<br>
                    ${assert(sticky, "mf_aftermath åªå†™ä¸€æ¬¡ï¼ˆä¸è¢«è¦†ç›–ï¼‰")}<br>
                `;

                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                const head = document.createElement('tr');
                ['#', 'day', 'tick', 'event', 'option', 'mind', 'flags', 'demon', 'hash'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    th.style.textAlign = 'left';
                    th.style.padding = '6px';
                    th.style.borderBottom = '1px solid #ddd';
                    head.appendChild(th);
                });
                table.appendChild(head);

                a.forEach((row, i) => {
                    const tr = document.createElement('tr');
                    const mind = `noise=${row.mf_noise ? '1' : '0'} strain=${row.mf_strain}`;
                    const flg = `interf=${row.mf_interference ? '1' : '0'} pressure=${row.mf_pressure ? '1' : '0'} resolved=${row.mf_resolved || '-'} aftermath=${row.mf_aftermath || '-'}`;
                    const cells = [
                        String(i + 1),
                        String(row.day),
                        String(row.tick),
                        row.eventId,
                        `${row.optionId} Â· ${row.optionText}`,
                        mind,
                        flg,
                        row.demonSeen ? 'yes' : 'no',
                        row.hash
                    ];
                    cells.forEach((c, idx) => {
                        const td = document.createElement('td');
                        td.style.padding = '6px';
                        td.style.borderBottom = '1px dashed #eee';
                        if (idx === 8) td.style.fontFamily = 'monospace';
                        td.textContent = c;
                        tr.appendChild(td);
                    });
                    table.appendChild(tr);
                });

                tl15.innerHTML = '';
                tl15.appendChild(table);
            }
        } catch (e) {
            r15.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            tl15.innerHTML = '';
            console.error(e);
        }

        const r16 = document.getElementById('result-16');
        const tl16 = document.getElementById('timeline-16');
        try {
            const hasWorld = (typeof gameState !== 'undefined' && gameState && typeof gameState.applyWorldUpdate === 'function');
            const hasEventSystem = (typeof EventSystem !== 'undefined' && EventSystem && typeof EventSystem.runEvent === 'function');
            const hasStoryTick = (typeof Rules !== 'undefined' && Rules && typeof Rules.storyTick === 'function');
            const hasGetEvent = (typeof Rules !== 'undefined' && Rules && typeof Rules.getEventById === 'function');
            const hasAvailability = (typeof Rules !== 'undefined' && Rules && typeof Rules.isEventAvailable === 'function');

            const canRun = hasWorld && hasEventSystem && hasStoryTick && hasGetEvent && hasAvailability;
            const startEvent = canRun ? Rules.getEventById('story_mindfracture_d1_01') : null;
            const gateEvent = canRun ? Rules.getEventById('event_world_chaos_03') : null;

            const safeWorldHash = () => {
                if (!gameState || typeof gameState.stableStringify !== 'function' || typeof gameState.hashFNV1a32 !== 'function') return null;
                const w = gameState.world && typeof gameState.world === 'object' ? gameState.world : null;
                const t = w && w.tendencies && typeof w.tendencies === 'object' ? w.tendencies : { order: 0, chaos: 0, omen: 0 };
                return gameState.hashFNV1a32(gameState.stableStringify({ tendencies: { order: t.order, chaos: t.chaos, omen: t.omen } }));
            };

            const pickOption = (event) => {
                if (!event || !Array.isArray(event.options) || !event.options.length) return null;
                const byId = (id) => event.options.find(o => o && o.id === id) || event.options[0];
                if (event.id === 'story_mindfracture_d1_01') return byId('endure');
                if (event.id === 'story_mindfracture_d2_01') return byId('continue');
                if (event.id === 'story_mindfracture_d3_01') return byId('ignore');
                if (event.id === 'story_mindfracture_d4_01') return byId('continue');
                if (event.id === 'story_mindfracture_d5_01') return byId('force_breakthrough');
                return event.options[0];
            };

            const runWorldSim = (seed) => {
                const baseRng = (typeof gameState.createSeededRng === 'function') ? gameState.createSeededRng(seed) : (() => 0.5);
                let seqIdx = 0;
                const seq = [0.99];
                const rng = () => {
                    if (seqIdx < seq.length) return seq[seqIdx++];
                    return baseRng();
                };

                gameState.rng = rng;
                gameState._deltaSeq = 0;
                gameState.hp = 60;
                gameState.maxHp = 60;
                gameState.mp = 80;
                gameState.maxMp = 80;
                gameState.exp = 0;
                gameState.realm = 'å¯»é“';
                gameState.stage = 'ç„é—¨';
                gameState.inventory = {};
                gameState.world = { tendencies: { order: 0, chaos: 0, omen: 0 } };
                gameState.story = { chainId: 'mindfracture', day: 1, step: 0, tick: 0, nextAtTick: 1, nextEventId: 'story_mindfracture_d1_01', flags: {}, completed: false };

                const history = [];
                const totalTicks = 80;

                const preAvail = gateEvent ? Rules.isEventAvailable(gateEvent, gameState.world) : null;
                for (let t = 0; t < totalTicks; t++) {
                    const tickRes = Rules.storyTick({ story: gameState.story });
                    if (tickRes && tickRes.storyUpdate && typeof tickRes.storyUpdate.tick === 'number') {
                        gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                    }
                    if (!tickRes || tickRes.trigger !== true || !tickRes.eventId) continue;
                    const event = Rules.getEventById(tickRes.eventId);
                    if (!event) continue;
                    const option = pickOption(event);
                    if (!option) continue;
                    const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('WorldTendency') : `WorldTendency#${t + 1}`;
                    const res = EventSystem.runEvent({
                        eventType: event.eventType,
                        event,
                        option,
                        deltaKey,
                        player: { hp: gameState.hp, mp: gameState.mp, maxHp: gameState.maxHp, maxMp: gameState.maxMp, atk: 14, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'éšæœº', statuses: [] },
                        env: { mapId: 'å¿ƒå¢ƒ', difficulty: 2 },
                        behaviorStats: { windowSize: 100, battles: 30, skillUses: { 'æ§é­‚': 3 }, chainSteps: 30, statusApplies: { fear: 1 }, dmgFromSkill: 120, dmgFromBasic: 80 }
                    }, gameState.rng, {});
                    if (res && typeof gameState.applyEventResult === 'function') gameState.applyEventResult(res);

                    const w = gameState.world && typeof gameState.world === 'object' ? gameState.world : null;
                    const tt = w && w.tendencies && typeof w.tendencies === 'object' ? w.tendencies : { order: 0, chaos: 0, omen: 0 };
                    history.push({
                        tick: gameState.story && typeof gameState.story.tick === 'number' ? gameState.story.tick : null,
                        eventId: event.id,
                        optionId: option.id,
                        deltaKey,
                        tendencies: { order: tt.order, chaos: tt.chaos, omen: tt.omen },
                        worldHash: safeWorldHash()
                    });
                    if (gameState.story && gameState.story.completed === true) break;
                }
                const postAvail = gateEvent ? Rules.isEventAvailable(gateEvent, gameState.world) : null;
                return { history, preAvail, postAvail };
            };

            if (!canRun || !startEvent || !gateEvent) {
                r16.innerHTML = `
                    ${assert(canRun, "World/Rules/Event æ¥å£å¯è¿è¡Œ")}<br>
                    ${assert(!!startEvent, "mindfracture èµ·ç‚¹äº‹ä»¶å­˜åœ¨")}<br>
                    ${assert(!!gateEvent, "å­˜åœ¨æ€§é—¨æ§äº‹ä»¶ event_world_chaos_03 å·²åŠ è½½")}<br>
                `;
                tl16.innerHTML = '';
            } else {
                const seed = 20260201;
                const a = runWorldSim(seed);
                const b = runWorldSim(seed);
                const same = JSON.stringify(a) === JSON.stringify(b);
                const last = a.history.length ? a.history[a.history.length - 1] : null;
                const chaos3 = !!(last && last.tendencies && Number(last.tendencies.chaos) >= 3);
                const unlocked = (a.preAvail === false && a.postAvail === true);
                const hasKeys = a.history.every(x => typeof x.deltaKey === 'string' && x.deltaKey.length);

                r16.innerHTML = `
                    ${assert(a.history.length >= 5, "å›ºå®šè·¯å¾„æ¨è¿›åˆ° Day5 ç»“ç®—")}<br>
                    ${assert(same, "åŒ seed å›æ”¾ä¸€è‡´æ€§ï¼ˆworld/äº‹ä»¶åºåˆ—/deltaKeyï¼‰")}<br>
                    ${assert(chaos3, "ç»“ç®—å tendencies.chaos è¾¾åˆ°é˜ˆå€¼ï¼ˆç”¨äº Existence è§£é”ï¼‰")}<br>
                    ${assert(unlocked, "Existence å±‚ï¼ševent_world_chaos_03 ä»ä¸å¯ç”¨å˜ä¸ºå¯ç”¨")}<br>
                    ${assert(hasKeys, "æ¯æ¬¡äº‹ä»¶éƒ½æœ‰ deltaKey è®°å½•")}<br>
                `;

                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';

                const head = document.createElement('tr');
                ['#', 'tick', 'event', 'option', 'tendencies', 'deltaKey', 'worldHash'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    th.style.textAlign = 'left';
                    th.style.padding = '6px';
                    th.style.borderBottom = '1px solid #ddd';
                    head.appendChild(th);
                });
                table.appendChild(head);

                a.history.forEach((row, i) => {
                    const tr = document.createElement('tr');
                    const cells = [
                        String(i + 1),
                        String(row.tick),
                        row.eventId,
                        row.optionId,
                        `order=${row.tendencies.order} chaos=${row.tendencies.chaos} omen=${row.tendencies.omen}`,
                        row.deltaKey,
                        row.worldHash
                    ];
                    cells.forEach((c, idx) => {
                        const td = document.createElement('td');
                        td.style.padding = '6px';
                        td.style.borderBottom = '1px dashed #eee';
                        if (idx === 5 || idx === 6) td.style.fontFamily = 'monospace';
                        td.textContent = c;
                        tr.appendChild(td);
                    });
                    table.appendChild(tr);
                });

                tl16.innerHTML = '';
                tl16.appendChild(table);
            }
        } catch (e) {
            r16.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            tl16.innerHTML = '';
            console.error(e);
        }

        const r17 = document.getElementById('result-17');
        const tl17 = document.getElementById('timeline-17');
        try {
            const hasStory = (typeof gameState !== 'undefined' && gameState && typeof gameState.applyStoryUpdate === 'function');
            const hasEventSystem = (typeof EventSystem !== 'undefined' && EventSystem && typeof EventSystem.runEvent === 'function');
            const hasStoryTick = (typeof Rules !== 'undefined' && Rules && typeof Rules.storyTick === 'function');
            const hasGetEvent = (typeof Rules !== 'undefined' && Rules && typeof Rules.getEventById === 'function');
            const canRun = hasStory && hasEventSystem && hasStoryTick && hasGetEvent;

            const safeHash = () => {
                if (!gameState || typeof gameState.stableStringify !== 'function' || typeof gameState.hashFNV1a32 !== 'function') return null;
                return gameState.hashFNV1a32(gameState.stableStringify({
                    hp: gameState.hp,
                    mp: gameState.mp,
                    exp: gameState.exp,
                    maxHp: gameState.maxHp,
                    maxMp: gameState.maxMp,
                    story: gameState.story,
                    world: gameState.world,
                    inventory: gameState.inventory
                }));
            };

            const initMindState = (seed, scenario) => {
                const baseRng = (typeof gameState.createSeededRng === 'function') ? gameState.createSeededRng(seed) : (() => 0.5);
                const s = scenario && typeof scenario === 'object' ? scenario : {};
                const seq = Array.isArray(s.rngSeq) ? s.rngSeq.map(Number).filter(x => Number.isFinite(x) && x >= 0 && x <= 1) : null;
                let seqIdx = 0;
                const rng = seq && seq.length
                    ? (() => () => (seqIdx < seq.length ? seq[seqIdx++] : baseRng()))()
                    : baseRng;
                gameState.rng = rng;
                gameState._deltaSeq = 0;
                const init = s.init && typeof s.init === 'object' ? s.init : {};
                gameState.hp = Number.isFinite(Number(init.hp)) ? Number(init.hp) : 140;
                gameState.maxHp = Number.isFinite(Number(init.maxHp)) ? Number(init.maxHp) : gameState.hp;
                gameState.mp = Number.isFinite(Number(init.mp)) ? Number(init.mp) : 80;
                gameState.maxMp = Number.isFinite(Number(init.maxMp)) ? Number(init.maxMp) : gameState.mp;
                gameState.exp = 0;
                gameState.realm = 'å¯»é“';
                gameState.subRealm = 'åˆæœŸ';
                gameState.stage = 'ç„é—¨';
                gameState.inventory = {};
                gameState.world = { tendencies: { order: 0, chaos: 0, omen: 0 } };
                gameState.currentMap = (typeof GameData !== 'undefined' && GameData.mapConfig && GameData.mapConfig['å°ä¹‰å±¯'])
                    ? GameData.mapConfig['å°ä¹‰å±¯']
                    : (typeof GameData !== 'undefined' && GameData.mapConfig ? GameData.mapConfig[Object.keys(GameData.mapConfig)[0]] : null);
                gameState.story = { chainId: 'mindfracture', day: 1, step: 0, tick: 0, nextAtTick: 1, nextEventId: 'story_mindfracture_d1_01', flags: {}, completed: false };
            };

            const pickOptionByReplay = (event, action) => {
                if (!event || !Array.isArray(event.options) || !event.options.length) return null;
                const desired = action && typeof action.optionId === 'string' ? action.optionId : null;
                if (desired) {
                    const found = event.options.find(o => o && o.id === desired);
                    if (found) return found;
                }
                return event.options[0];
            };

            const simulateAndBuildReplay = (seed, scenario) => {
                initMindState(seed, scenario);
                const history = [];
                const actions = [];
                const totalTicks = 120;
                for (let t = 0; t < totalTicks; t++) {
                    const tickRes = Rules.storyTick({ story: gameState.story });
                    if (tickRes && tickRes.storyUpdate && typeof tickRes.storyUpdate.tick === 'number') {
                        gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                    }
                    if (!tickRes || tickRes.trigger !== true || !tickRes.eventId) continue;
                    const event = Rules.getEventById(tickRes.eventId);
                    if (!event) continue;
                    const option = (() => {
                        if (!Array.isArray(event.options) || !event.options.length) return null;
                        const byId = (id) => event.options.find(o => o && o.id === id) || event.options[0];
                        if (event.id === 'story_mindfracture_d1_01') return byId('endure');
                        if (event.id === 'story_mindfracture_d2_01') return byId('continue');
                        if (event.id === 'story_mindfracture_d3_01') return byId('ignore');
                        if (event.id === 'story_mindfracture_d4_01') return byId('continue');
                        if (event.id === 'story_mindfracture_d5_01') return byId('face_demon');
                        return event.options[0];
                    })();
                    if (!option) continue;
                    const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('ReplayBuild') : `ReplayBuild#${t + 1}`;
                    const res = EventSystem.runEvent({
                        eventType: event.eventType,
                        event,
                        option,
                        deltaKey,
                        player: { hp: gameState.hp, mp: gameState.mp, maxHp: gameState.maxHp, maxMp: gameState.maxMp, atk: 14, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'éšæœº', statuses: [] },
                        env: { mapId: 'å¿ƒå¢ƒ', difficulty: 2 },
                        behaviorStats: { windowSize: 100, battles: 30, skillUses: { 'æ§é­‚': 3 }, chainSteps: 30, statusApplies: { fear: 1 }, dmgFromSkill: 120, dmgFromBasic: 80 }
                    }, gameState.rng, {});
                    if (res && typeof gameState.applyEventResult === 'function') gameState.applyEventResult(res);
                    const row = { tick: gameState.story.tick, eventId: event.id, optionId: option.id, deltaKey, hash: safeHash() };
                    history.push(row);
                    actions.push({ eventId: event.id, optionId: option.id });
                    if (gameState.story && gameState.story.completed === true) break;
                }
                const replay = {
                    version: "V2-replay",
                    seed,
                    scenario: scenario && typeof scenario === 'object' ? JSON.parse(JSON.stringify(scenario)) : {},
                    actions
                };
                return { replay, history };
            };

            const runReplay = (replay) => {
                const seed = replay && Number.isFinite(Number(replay.seed)) ? Number(replay.seed) : 0;
                const scenario = replay && replay.scenario && typeof replay.scenario === 'object' ? replay.scenario : {};
                const actions = Array.isArray(replay && replay.actions) ? replay.actions : [];
                initMindState(seed, scenario);
                const out = [];
                const maxTicks = 200;
                let actIdx = 0;
                for (let t = 0; t < maxTicks && actIdx < actions.length; t++) {
                    const tickRes = Rules.storyTick({ story: gameState.story });
                    if (tickRes && tickRes.storyUpdate && typeof tickRes.storyUpdate.tick === 'number') {
                        gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                    }
                    if (!tickRes || tickRes.trigger !== true || !tickRes.eventId) continue;
                    const expected = actions[actIdx];
                    if (!expected || expected.eventId !== tickRes.eventId) {
                        out.push({ tick: gameState.story.tick, eventId: tickRes.eventId, optionId: null, deltaKey: null, hash: safeHash(), mismatch: true, expected: expected ? expected.eventId : null });
                        break;
                    }
                    const event = Rules.getEventById(tickRes.eventId);
                    if (!event) break;
                    const option = pickOptionByReplay(event, expected);
                    const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('ReplayRun') : `ReplayRun#${t + 1}`;
                    const res = EventSystem.runEvent({
                        eventType: event.eventType,
                        event,
                        option,
                        deltaKey,
                        player: { hp: gameState.hp, mp: gameState.mp, maxHp: gameState.maxHp, maxMp: gameState.maxMp, atk: 14, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'éšæœº', statuses: [] },
                        env: { mapId: 'å¿ƒå¢ƒ', difficulty: 2 },
                        behaviorStats: { windowSize: 100, battles: 30, skillUses: { 'æ§é­‚': 3 }, chainSteps: 30, statusApplies: { fear: 1 }, dmgFromSkill: 120, dmgFromBasic: 80 }
                    }, gameState.rng, {});
                    if (res && typeof gameState.applyEventResult === 'function') gameState.applyEventResult(res);
                    out.push({ tick: gameState.story.tick, eventId: event.id, optionId: option && option.id ? option.id : null, deltaKey, hash: safeHash() });
                    actIdx++;
                    if (gameState.story && gameState.story.completed === true) break;
                }
                return out;
            };

            if (!canRun) {
                r17.innerHTML = `
                    ${assert(hasStory, "gameState.applyStoryUpdate å­˜åœ¨")}<br>
                    ${assert(hasEventSystem, "EventSystem.runEvent å­˜åœ¨")}<br>
                    ${assert(hasStoryTick, "Rules.storyTick å­˜åœ¨")}<br>
                    ${assert(hasGetEvent, "Rules.getEventById å­˜åœ¨")}<br>
                `;
                tl17.innerHTML = '';
            } else {
                const seed = 20260201;
                const scenario = { rngSeq: [0.3, 0.3, 0.3], init: { hp: 140, mp: 80, maxHp: 140, maxMp: 80 } };
                const built = simulateAndBuildReplay(seed, scenario);
                const a = runReplay(built.replay);
                const b = runReplay(built.replay);
                const sameReplay = JSON.stringify(a) === JSON.stringify(b);
                const sameAsBuild = JSON.stringify(a.map(x => ({ tick: x.tick, eventId: x.eventId, optionId: x.optionId, hash: x.hash }))) === JSON.stringify(built.history.map(x => ({ tick: x.tick, eventId: x.eventId, optionId: x.optionId, hash: x.hash })));
                const hasKeys = a.every(x => typeof x.deltaKey === 'string' && x.deltaKey.length);
                const mismatch = a.some(x => x.mismatch === true);
                const last = a.length ? a[a.length - 1] : null;

                r17.innerHTML = `
                    ${assert(built.replay && built.replay.version === 'V2-replay', "replay å¯¹è±¡ç”ŸæˆæˆåŠŸ")}<br>
                    ${assert(!mismatch, "replay é©±åŠ¨çš„äº‹ä»¶åºåˆ—ä¸é¢„æœŸä¸€è‡´")}<br>
                    ${assert(sameReplay, "åŒ replay é‡æ”¾ä¸€è‡´")}<br>
                    ${assert(sameAsBuild, "replay é‡æ”¾ä¸åŸæ¨¡æ‹Ÿ hash/åºåˆ—ä¸€è‡´")}<br>
                    ${assert(hasKeys, "é‡æ”¾æ¯æ­¥éƒ½æœ‰ deltaKey")}<br>
                    æœ€ç»ˆ hashï¼š<span class="log-line">${last ? last.hash : 'N/A'}</span><br>
                `;

                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.fontSize = '12px';
                const head = document.createElement('tr');
                ['#', 'tick', 'event', 'option', 'deltaKey', 'hash'].forEach(h => {
                    const th = document.createElement('th');
                    th.textContent = h;
                    th.style.textAlign = 'left';
                    th.style.padding = '6px';
                    th.style.borderBottom = '1px solid #ddd';
                    head.appendChild(th);
                });
                table.appendChild(head);
                a.forEach((row, i) => {
                    const tr = document.createElement('tr');
                    const cells = [String(i + 1), String(row.tick), row.eventId, row.optionId, row.deltaKey, row.hash];
                    cells.forEach((c, idx) => {
                        const td = document.createElement('td');
                        td.style.padding = '6px';
                        td.style.borderBottom = '1px dashed #eee';
                        if (idx === 4 || idx === 5) td.style.fontFamily = 'monospace';
                        td.textContent = c;
                        tr.appendChild(td);
                    });
                    table.appendChild(tr);
                });
                tl17.innerHTML = '';
                tl17.appendChild(table);
            }
        } catch (e) {
            r17.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
            tl17.innerHTML = '';
            console.error(e);
        }
    </script>
    </div>
        <!-- æµ‹è¯• 18: V2 å†»ç»“æç«¯ç”¨ä¾‹ -->
        <div class="test-box">
            <h3>Test 18: V2 Freeze Extreme Cases (Long Sequence & Destructive)</h3>
            <p class="desc">
                éªŒè¯ï¼š1. é•¿åºåˆ—ï¼ˆ60 tickï¼‰ä¸€è‡´æ€§ï¼›2. ç ´åæ€§æµ‹è¯•ï¼ˆä¿®æ”¹é€»è¾‘å Replay æ˜¯å¦æ˜ç¡®å¤±è´¥ï¼‰ã€‚
            </p>
            <div id="result-18" class="result">Running...</div>
        </div>

        <script>
        (function() {
            // --- é€šç”¨å·¥å…· ---
            const assert = (cond, msg) => cond 
                ? `<span class="pass">âœ” ${msg}</span>` 
                : `<span class="fail">âœ˜ ${msg}</span>`;

            // --- æµ‹è¯• 18: V2 å†»ç»“æç«¯ç”¨ä¾‹ ---
            const r18 = document.getElementById('result-18');
            try {
                const safeHash18 = () => {
                    if (!gameState || typeof gameState.stableStringify !== 'function' || typeof gameState.hashFNV1a32 !== 'function') return null;
                    return gameState.hashFNV1a32(gameState.stableStringify({
                        hp: gameState.hp, mp: gameState.mp, exp: gameState.exp,
                        maxHp: gameState.maxHp, maxMp: gameState.maxMp,
                        story: gameState.story, world: gameState.world, inventory: gameState.inventory
                    }));
                };

                const initSim18 = (seed) => {
                    const rng = (typeof gameState.createSeededRng === 'function') ? gameState.createSeededRng(seed) : (() => 0.5);
                    gameState.rng = rng;
                    gameState.hp = 140; gameState.maxHp = 140;
                    gameState.mp = 80; gameState.maxMp = 80;
                    gameState.exp = 0;
                    gameState.realm = 'å¯»é“'; gameState.stage = 'ç„é—¨';
                    gameState.inventory = {};
                    gameState.world = { tendencies: { order: 0, chaos: 0, omen: 0 } };
                    gameState.story = { chainId: 'mindfracture', day: 1, step: 0, tick: 0, nextAtTick: 1, nextEventId: 'story_mindfracture_d1_01', flags: {}, completed: false };
                };

                const runSim18 = (seed, length) => {
                    initSim18(seed);
                    const history = [];
                    const actions = [];
                    for (let t = 0; t < length; t++) {
                        const tickRes = Rules.storyTick({ story: gameState.story });
                        if (tickRes && tickRes.storyUpdate && tickRes.storyUpdate.tick) {
                            gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                        }
                        if (!tickRes || !tickRes.trigger || !tickRes.eventId) continue;

                        const event = Rules.getEventById(tickRes.eventId);
                        if (!event) continue;
                        const option = event.options && event.options.length ? event.options[0] : null;

                        const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('Test18') : `Test18#${t}`;
                        const res = EventSystem.runEvent({
                            eventType: event.eventType, event, option, deltaKey,
                            player: { ...gameState }, env: { mapId: 'å¿ƒå¢ƒ' }
                        }, gameState.rng, {});
                        if (res && gameState.applyEventResult) gameState.applyEventResult(res);

                        history.push({ tick: gameState.story.tick, eventId: event.id, hash: safeHash18() });
                        actions.push({ eventId: event.id, optionId: option ? option.id : null });
                        if (gameState.story.completed) break;
                    }
                    return { history, actions, finalHash: history.length ? history[history.length-1].hash : null };
                };

                const runReplay18 = (seed, actions) => {
                    initSim18(seed);
                    const history = [];
                    let actIdx = 0;
                    for (let t = 0; t < 200 && actIdx < actions.length; t++) {
                        const tickRes = Rules.storyTick({ story: gameState.story });
                        if (tickRes && tickRes.storyUpdate && tickRes.storyUpdate.tick) {
                            gameState.applyStoryUpdate({ tick: tickRes.storyUpdate.tick }, { source: 'Rules.storyTick' });
                        }
                        if (!tickRes || !tickRes.trigger || !tickRes.eventId) continue;

                        const expected = actions[actIdx];
                        if (!expected || expected.eventId !== tickRes.eventId) {
                            history.push({ error: 'Mismatch', expected: expected ? expected.eventId : null, actual: tickRes.eventId });
                            break;
                        }
                        const event = Rules.getEventById(tickRes.eventId);
                        const option = event.options.find(o => o.id === expected.optionId);

                        const deltaKey = (typeof gameState.makeDeltaKey === 'function') ? gameState.makeDeltaKey('Test18Replay') : `Test18Replay#${t}`;
                        const res = EventSystem.runEvent({
                            eventType: event.eventType, event, option, deltaKey,
                            player: { ...gameState }, env: { mapId: 'å¿ƒå¢ƒ' }
                        }, gameState.rng, {});
                        if (res && gameState.applyEventResult) gameState.applyEventResult(res);

                        history.push({ tick: gameState.story.tick, eventId: event.id, hash: safeHash18() });
                        actIdx++;
                        if (gameState.story.completed) break;
                    }
                    return { history, finalHash: history.length ? history[history.length-1].hash : null };
                };

                const seed = 20269999;

                // 1. Long Run
                const runA = runSim18(seed, 60);
                const replayA = runReplay18(seed, runA.actions);
                const matchLong = (runA.finalHash === replayA.finalHash);

                // 2. Destructive Test
                const originalRunEvent = EventSystem.runEvent;
                let tamperDetected = false;
                try {
                    // Simulate "Rules Changed" by patching logic to produce different numeric results
                    EventSystem.runEvent = function(ctx, rng, opts) {
                        const res = originalRunEvent.call(this, ctx, rng, opts);
                        if (res) {
                            // Force a narrative state change that definitively alters the hash
                            if (!res.flags) res.flags = {};
                            if (!res.flags.story) res.flags.story = {};
                            if (!res.flags.story.setFlags) res.flags.story.setFlags = {};
                            res.flags.story.setFlags['TAMPERED_TEST'] = true;
                        }
                        return res;
                    };

                    const replayTampered = runReplay18(seed, runA.actions);
                    if (replayTampered.finalHash !== runA.finalHash) {
                        tamperDetected = true;
                    }
                } finally {
                    EventSystem.runEvent = originalRunEvent;
                }

                r18.innerHTML = `
                    ${assert(runA.history.length >= 5, "é•¿åºåˆ—è¿è¡Œ (60 ticks) æˆåŠŸ (>=5 events)")}<br>
                    ${assert(matchLong, "é•¿åºåˆ— Replay Hash å®Œå…¨ä¸€è‡´")}<br>
                    ${assert(tamperDetected, "ç ´åæ€§æµ‹è¯•ï¼šä¿®æ”¹è§„åˆ™é€»è¾‘åï¼ŒReplay æ˜ç¡®æ£€æµ‹åˆ°çŠ¶æ€åç¦»")}<br>
                `;

            } catch (e) {
                r18.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
                console.error(e);
            }
        })();
        </script>
    </div>
        <div class="test-box">
            <h3>Test 19: Dao/Skill v2.0 Core Checks</h3>
            <p class="desc">éªŒè¯ï¼šæŠ€èƒ½æ‹†è¡¨åŠ è½½ã€å¤©ä¸€é“å¤ç°æ± ç”Ÿæˆã€é˜´é˜³é€†è½¬å†™å…¥ mapState effectã€é¬¼é“å¬å”¤å†™å…¥ ghosts effectã€ä¹¾å¤é“çµä½“ç‰¹æ”»å€ç‡ã€‚</p>
            <div id="result-19" class="result">Running...</div>
        </div>

        <script>
        (function() {
            const r19 = document.getElementById('result-19');
            const assert = (cond, msg) => cond 
                ? `<span class="pass">âœ” ${msg}</span>` 
                : `<span class="fail">âœ˜ ${msg}</span>`;
            try {
                const hasSkills = (typeof GameData !== 'undefined' && GameData && GameData.skillConfig && typeof GameData.skillConfig === 'object');
                const keys = hasSkills ? Object.keys(GameData.skillConfig) : [];
                const hasDaos = hasSkills && ['é¬¼é“', 'é˜´é˜³é“', 'ä¹¾å¤é“', 'å¤©ä¸€é“'].every(k => keys.includes(k));

                const mkRng = (v) => () => v;
                const mkCtx = (player, monster, env) => ({
                    round: 0,
                    player,
                    monsters: [monster],
                    env
                });

                const tianyiPoolHasRepro = (() => {
                    if (typeof CombatEngine === 'undefined' || !CombatEngine || typeof CombatEngine.getSkill !== 'function') return false;
                    const s = CombatEngine.getSkill('å¤©ä¸€é“', 'å¯»é“', 'åˆæœŸ', { mapId: 'T', difficulty: 1 }, mkRng(0.99));
                    return !!(s && typeof s.name === 'string' && s.name.startsWith('å¤ç°Â·'));
                })();

                const invertHasEffect = (() => {
                    if (typeof CombatEngine === 'undefined' || !CombatEngine || typeof CombatEngine.run !== 'function') return false;
                    const res = CombatEngine.run(
                        mkCtx({ hp: 100, mp: 200, maxHp: 100, maxMp: 200, atk: 10, matk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é˜´é˜³é“' }, { id: 'm0', name: 'èµ°å°¸', hp: 100, atk: 10, tags: [] }, { mapId: 'æ—§å®—é—å€', difficulty: 1, yinYang: 1 }),
                        mkRng(0.3),
                        { skillName: 'é€†è½¬' }
                    );
                    return Array.isArray(res && res.effects) && res.effects.some(e => e && e.target === 'mapState' && e.type === 'invertYinYang' && e.meta && e.meta.external === true);
                })();

                const summonHasEffect = (() => {
                    if (typeof CombatEngine === 'undefined' || !CombatEngine || typeof CombatEngine.run !== 'function') return false;
                    const res = CombatEngine.run(
                        mkCtx({ hp: 100, mp: 200, maxHp: 100, maxMp: 200, atk: 10, matk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'é¬¼é“', ghosts: [], soulUrn: { capacity: 2 } }, { id: 'm0', name: 'èµ°å°¸', hp: 100, atk: 10, tags: [] }, { mapId: 'ä¹‰åº„', difficulty: 1, yinYang: 0 }),
                        mkRng(0.3),
                        { skillName: 'æ‹›é¬¼' }
                    );
                    return Array.isArray(res && res.effects) && res.effects.some(e => e && e.target === 'ghosts' && e.type === 'add' && e.meta && e.meta.external === true);
                })();

                const qiankunSpiritBonus = (() => {
                    if (typeof CombatEngine === 'undefined' || !CombatEngine || typeof CombatEngine.run !== 'function') return false;
                    const runOne = (isSpirit) => {
                        const logs = [];
                        const res = CombatEngine.run(
                            mkCtx({ hp: 100, mp: 200, maxHp: 100, maxMp: 200, atk: 20, matk: 10, realm: 'å¯»é“', subRealm: 'åˆæœŸ', activeDao: 'ä¹¾å¤é“', daoType: 'ä¹¾å¤é“' }, { id: 'm0', name: 'æ€¨çµ', hp: 200, atk: 10, tags: isSpirit ? ['spirit'] : [] }, { mapId: 'ä¹‰åº„', difficulty: 1, yinYang: 0 }),
                            mkRng(0.3),
                            { skillName: 'è¸ç ´' }
                        );
                        if (res && Array.isArray(res.logs)) logs.push(...res.logs);
                    const dmgLog = logs.find(l => l && typeof l.text === 'string' && l.tag === 'skill' && l.meta && l.meta.skillName === 'è¸ç ´' && l.text.includes('é€ æˆ') && l.text.includes('ä¼¤å®³'));
                    const m = dmgLog && dmgLog.text.match(/é€ æˆ\s*(\d+)\s*ä¼¤å®³/);
                        return m ? Number(m[1]) : 0;
                    };
                    const a = runOne(false);
                    const b = runOne(true);
                    return b > a;
                })();

                r19.innerHTML = `
                    ${assert(hasDaos, "æŠ€èƒ½æ‹†è¡¨åŠ è½½ï¼šå››å¤§é“ç»Ÿ skillConfig å°±ç»ª")}<br>
                    ${assert(tianyiPoolHasRepro, "å¤©ä¸€é“ï¼šå¤ç°æŠ€èƒ½æ± ç”Ÿæˆ")}<br>
                    ${assert(invertHasEffect, "é˜´é˜³é€†è½¬ï¼šäº§ç”Ÿ mapState ç¿»è½¬ effect")}<br>
                    ${assert(summonHasEffect, "é¬¼é“æ‹›é¬¼ï¼šäº§ç”Ÿ ghosts.add effect")}<br>
                    ${assert(qiankunSpiritBonus, "ä¹¾å¤é“ï¼šå¯¹çµä½“ä¼¤å®³æ›´é«˜")}<br>
                `;
            } catch (e) {
                r19.innerHTML = `<span class="fail">ğŸ’¥ è¿è¡Œæ—¶é”™è¯¯: ${e.message}</span>`;
                console.error(e);
            }
        })();
        </script>
</body>
</html>




